<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>空间旋转</title>
      <link href="/2023/01/15/math/kong-jian-xuan-zhuan/"/>
      <url>/2023/01/15/math/kong-jian-xuan-zhuan/</url>
      
        <content type="html"><![CDATA[<h3 id="空间旋转"><a href="#空间旋转" class="headerlink" title="空间旋转"></a>空间旋转</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前的一次打比赛中，由于三维空间的特征属于强特，其正样本分布在空间中的一个平面上，所以采用树模型进行分类的时候最好的办法是将数据所在三维空间进行旋转，使得三维平面统一垂直与某个坐标轴。方便树模型切分数据。</p><h4 id="平面求解"><a href="#平面求解" class="headerlink" title="平面求解"></a>平面求解</h4><p>三维空间中的平面可以用 $z &#x3D; ax+by+c$ 表示，于是m个离散点可以组成方程组 </p>$$\left|\begin{array}{ccc}x_1 & y_1 & 1 \\x_2 & y_2 & 1 \\x_3 & y_3 & 1 \\\vdots & \vdots \\x_m & y_m & 1\end{array}\right| \cdot\left|\begin{array}{ccc}a  \\b \\c  \\\end{array}\right|=\left|\begin{array}{c}a \\z_1 \\z_2 \\z_3 \\z_m\end{array}\right|$$上述方程可以表示为 $AX=b$   由于A是一个 $m \times n$的矩阵 在求逆的过程中分别乘以A的转置 $A^T$ 使得矩阵变成方阵的时候通过求逆矩阵来求解 也就是 $X = (AA^T)^{-1}A^Tb$#### 旋转矩阵设某个单位正交基$[e_1, e_2, e_3]$ 经过旋转变成了 $[e_1', e_2', e_3']$, 对于同一个向量 $\alpha$ ，向量本身没有随着坐标系旋转而运动，他在两个坐标系下的坐标为$\left(a_1, a_2, a_3\right)^T \text { 和 }\left(a_1', a_2', a_3'\right)^T$, 那么有$$\left[e_1, e_2, e_3\right]\left[\begin{array}{l}a_1 \\a_2 \\a_3\end{array}\right]=\left[e_1^{\prime}, e_2^{\prime}, e_3^{\prime}\right]\left[\begin{array}{l}a_1^{\prime} \\a_2 \\a_3^{\prime}\end{array}\right]$$$$$$$$\begin{array}{r}{\left[\begin{array}{l}a_1 \\a_2 \\a_3\end{array}\right]=\left[\begin{array}{lll}e_1^T e_1^{\prime} & e_1^T e_2^{\prime} & e_1^T e_3^{\prime} \\e_2^T e_1^{\prime} & e_2^T e_2^{\prime} & e_1^T e_3^{\prime} \\e_3^T e_1^{\prime} & e_3^T e_2^2 & e_3^T e_3^{\prime}\end{array}\right]\left[\begin{array}{l}a_1^{\prime} \\a_2^{\prime} \\a_3\end{array}\right]=R \boldsymbol{a}^{\prime}(2)} \\\end{array}$$于是令：$$R=\left[\begin{array}{ccc}e_1^T e_1^{\prime} & e_1^T e_2^{\prime} & e_1^T e_3^{\prime} \\e_2^T e_1^{\prime} & e_2^T e_2^{\prime} & e_1^T e_3^{\prime} \\e_3^T e_1^{\prime} & e_3^T e_2^{\prime} & e_3^T e_3^{\prime}\end{array}\right] \text { (3) }$$则$R$ 称为 空间变换的一个核]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo_Install_Record</title>
      <link href="/2023/01/14/cs/hexo-install-record/"/>
      <url>/2023/01/14/cs/hexo-install-record/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p> 记录一次安装过程和一些后续快速查找的博客</p><h3 id="安装npm-和Node-js"><a href="#安装npm-和Node-js" class="headerlink" title="安装npm 和Node.js"></a>安装npm 和Node.js</h3><p>略</p><p>检查是否安装成功</p><blockquote><p>node -v<br>npm -v</p></blockquote><p>添加国内镜像</p><blockquote><p>npm config set registry https:<em>&#x2F;&#x2F;registry.npm.taobao.org</em></p></blockquote><h3 id="认识Hexo"><a href="#认识Hexo" class="headerlink" title="认识Hexo"></a>认识Hexo</h3><blockquote><p>npm install -g hexo-cli<br>hexo -v</p></blockquote><p>初始化</p><blockquote><p>hexo init</p><p>npm install </p></blockquote><blockquote><p>- </p></blockquote><p>输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器</p><blockquote><p>hexo g</p><p>hexo server(s)</p></blockquote><h3 id="github-配置"><a href="#github-配置" class="headerlink" title="github 配置"></a>github 配置</h3><p>第一次使用git后需要将用户名和邮箱进行初始化</p><blockquote><p>git config –global user.name “Y…” </p><p>git config –global user.email “<a href="mailto:&#76;&#64;&#x78;&#120;&#46;&#99;&#111;&#109;">&#76;&#64;&#x78;&#120;&#46;&#99;&#111;&#109;</a>“</p></blockquote><p>check</p><blockquote><p>git config user.name<br>git config user.email</p></blockquote><blockquote><p>ssh-keygen -t rsa -C “L@..”  # 生成ssh</p></blockquote><p>将输出的内容添加在github的的setting 中的 SSH and GPG kes </p><blockquote><p>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</p></blockquote><p>测试 为</p><blockquote><p>ssh -T <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;</a>  # 出现用户名就ok</p></blockquote><h3 id="将hexo-部署到github"><a href="#将hexo-部署到github" class="headerlink" title="将hexo 部署到github"></a>将hexo 部署到github</h3><p>我们可以将<code>hexo</code>和<code>GitHub</code>关联起来，也就是将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开博客根目录下的<code>_config.yml</code>文件</p><ul><li><p>安装部署使用到的git插件</p><blockquote><p>npm install hexo-deployer-git -save</p></blockquote></li><li><p>修改最后一行配置</p><blockquote><p>deploy:  </p><pre><code>type: git                  repository: https://github.com/gaoziman/gaoziman.github.io.git                  branch: master</code></pre></blockquote></li><li><p>生成 其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。 <code>hexo generate</code>顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写</p><blockquote><p>hexo clean </p><p>hexo generate </p><p>hexo deploy</p></blockquote></li></ul><h3 id="添加自定义域名"><a href="#添加自定义域名" class="headerlink" title="添加自定义域名"></a>添加自定义域名</h3><p>此处仅仅列举一些步骤，我暂时没有买域名</p><ul><li>去买域名的地方添加解析</li><li>在github中的setting 中pages中 custom domain 中添加自己的域名</li><li>github的项目根目录会出现一个CNAME的文件，如果没有的话 打开本地博客的&#x2F;source 目录， 新建<code>CNAME</code>文件，没有后缀，写上自己的域名，保存 运行hexo g， hexo d 上传github</li></ul><h3 id="写文章，发布文章"><a href="#写文章，发布文章" class="headerlink" title="写文章，发布文章"></a>写文章，发布文章</h3><p>记得安装扩展 <code>npm i hexo-deployer-git</code></p><ul><li>新建一篇文章 <code>hexo new post &quot;file_name&quot;</code></li><li>在<code>source\_posts\</code> 路径下会生成一个file_name.md 文件，但是并没有多一个文件夹（有个小bug，用typora自带的图片保存路径并不会成功显示在网页上，应该是生成网页的时候没有找到图片</li><li>hexo g | hexo s</li></ul><h3 id="hexo-进一步认识"><a href="#hexo-进一步认识" class="headerlink" title="hexo 进一步认识"></a>hexo 进一步认识</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><blockquote><ul><li><code>node_modules:</code> 依赖包,各种库</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板，有三个文件，存储这新文章和新页面的初试设置</li><li><code>source：</code>用来存放你的文章，各类页面，图像等文件<ul><li>_data</li><li>_posts  <strong>重点文件</strong></li><li>about</li><li>archives</li><li>categories</li><li>friends</li><li>tags</li></ul></li><li><code>themes：</code>主题**</li><li><code>_config.yml:</code> 博客的配置文件**</li></ul></blockquote><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><h5 id="base-config"><a href="#base-config" class="headerlink" title="base config"></a>base config</h5><p>文件根目录中的 _config.yml 就是整个hexo的配置文件 <a href="https://hexo.io/zh-cn/docs/configuration.html">参考</a></p><blockquote><p>author: 作者名</p><p>language: 语言</p><p>description：<code>description</code>主要用于<code>SEO</code>，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词</p><p>….</p><p>url：网址root根目录，也就是域名</p><p>permalink: 文章生成连接的格式</p><p>theme : 主题</p></blockquote><h5 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h5><p>是一篇文章最上方以— 分割的区域， 用于指定个别文件的变量</p><blockquote><p>title: Hexo+Github博客搭建记录 </p><p>date: 2022-05-08 15:15:44</p></blockquote><pre class="line-numbers language-none"><code class="language-none">--- title: Hexo+Github博客搭建记录 date: 2022-05-08 15:15:44 author: nameimg: &#x2F;medias&#x2F;banner&#x2F;7.jpg coverImg: &#x2F;medias&#x2F;banner&#x2F;7.jpg top: true cover: true toc: true password: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110 mathjax: true summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 tags: - Hexo - Github - 博客 categories: - 软件安装与配置 ---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注明：分类具有顺序性和层次性，标签没有顺序和层次，标签中的 A,B 等于B,A</p><h3 id="BUGS"><a href="#BUGS" class="headerlink" title="BUGS"></a>BUGS</h3><ul><li><p>win10本来已经通过npm 安装好了hexo 然后始终 报错<code>bash: hexo: command not found</code><br>, 然后找寻解决方法是没有将node 的安装目录加入环境变量，通过以下两个命令寻找路径，</p><ul><li><p>查看node_modules的目录，执行：npm root -g</p></li><li><p>查看npm的可执行文件所在目录：npm bin -g</p><p><img src="/BlogImgs/$%7Bfiilename%7D/image-20230114081824222.png" alt="可疑记录"></p><p>于是将两个路径分别添加到path，重启cmd就能正常使用hexo</p></li></ul><p><a href="https://blog.51cto.com/u_14900374/2553812">ref1</a>, <a href="https://blog.51cto.com/u_15176340/2723817">ref2</a>, ref2 中的 npx ：npx 想要解决的主要问题，就是调用项目内部安装的模块”，所以可以理解为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在，所以系统命令也可以调用，即上面的命令安装不成功的时候加上npx的话也许就可以成功了</p></li><li><p>OpenSSL SSL_read: Connection was reset, errno 10054 </p><p>重新检测了一下是否能与github连接 <code>ssh git@github.com</code>,  然后查找博客将config中的网址替换为ssh</p><blockquote><p><a href="https://github.com/gaoziman/gaoziman.github.io.git">https://github.com/gaoziman/gaoziman.github.io.git</a>   这个网址不行<br>替换为 hexo config deploy.repository <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a>:[yourgitname]&#x2F;[yourgitname].github.io.git</p></blockquote></li><li><p>高亮问题</p><p>代码高亮出现极其诡异的现象 hexo matery 通过搜索查找方案如下<a href="https://www.pudn.com/news/6228dc5e9ddf223e1ad287ce.html">ref</a></p><p><img src="/source/BlogImgs/Hexo-Install-Record/image-20230115194720929.png" alt="image-20230115194720929"></p><p>禁用<code>highlight</code> 启用<code>prismjs</code></p><p><img src="/source/BlogImgs/Hexo-Install-Record/image-20230115194855418.png" alt="image-20230115194855418"></p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.cn/post/7095323643277738014">https://juejin.cn/post/7095323643277738014</a>: 这篇文章介绍的很详细，尤其是关于hexo的生态上，介绍了很多hexo的高级操作，但本人目前主要想要一个的可以简单的博客，后续的各种操作就没有借鉴了</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实还蛮简单的，因为目前我的需求并不是曝光我的网站，而只是将一些总结打包出来，所以有很多东西并没有尝试，等以后有需求一定要完善起来现将一些攻略总结如下！</p><ul><li>这篇文章对我的帮助巨巨巨大： <a href="https://juejin.cn/post/7095323643277738014">https://juejin.cn/post/7095323643277738014</a> 剩下的包括一些速度优化，评论，网站推广等一些细节等还没有尝试</li><li>matery 的官网文档 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a> 但是最重要的还是要对主题中的_config.yml 进行阅读，其中已经比较详细</li><li>在这个人写的博客中也有一些东西， 但是没有太多关注 <a href="https://developer.aliyun.com/profile/expert/z3jcatjk57fiu">https://developer.aliyun.com/profile/expert/z3jcatjk57fiu</a></li><li>这是一位大佬的博客，挺好看的，我借鉴他的博客改了一下背景，后续仍然可以参考优化 <a href="https://github.com/godweiyang/hexo-theme-sungod">https://github.com/godweiyang/hexo-theme-sungod</a> 展示<a href="https://godweiyang.com/">地址</a></li><li>是个大佬，但是没有仔细膜拜，他的页面很简洁，挺好看 <a href="https://www.cnblogs.com/all-smile/p/16608503.html#hexo%E4%B8%BB%E9%A2%98">https://www.cnblogs.com/all-smile/p/16608503.html#hexo%E4%B8%BB%E9%A2%98</a></li><li>HEXO 官方文档</li><li>还有一些是背景图，进度条，top按钮等的颜色 <a href="https://blog.csdn.net/cungudafa/article/details/106278206">ref1</a>, <a href="https://thecara.github.io/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">ref2</a></li><li>往Hexo 加入PDF <a href="https://zhuanlan.zhihu.com/p/550626417">https://zhuanlan.zhihu.com/p/550626417</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 安装记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后处理之优化结果</title>
      <link href="/2023/01/11/competition/hou-chu-li-zhi-you-hua-jie-guo/"/>
      <url>/2023/01/11/competition/hou-chu-li-zhi-you-hua-jie-guo/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在打一些比赛的时候，会遇到一些对阈值很敏感的评价指标，比如$f1$ ,或者是在一些回归任务中，需要对模型得到结果进一步处理，使结果能相对于处理前能提升一些分数。而这些会往往会涉及到对一些阈值参数的选取，例如，当使用 $f1$ 当做评价指标的时候往往会因为阈值的选取的不同，划分正负样本的不一样而导致结果往往相差很多</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>一句话总结，就是将待选取的参数视为未知参数，用优化算法得到使评价指标最 大&#x2F;小 化的参数</strong></p><p>假设一个任务是二分类，我们的模型在验证集 (validation dataset) 上预测了一个结果 $y_{pred}$ , 我们的评价指标为 $G$函数，而我们将模型进行后处理的函数为 $H(y_{pred}, \alpha_1, \alpha_2,…)$, 其中$\alpha_1, \alpha_2,…$是待确定的参数，则最后的由评价函数得到的评价结果 $Result &#x3D; G(H(y_{pred}, \alpha_1, \alpha_2,…), y_{true})$,我们将整体视为一个目标函数，使用优化算法去得到使得结果最好的$\alpha_1, \alpha_2,…$，当我们在验证集计算得到最好的参数，我们则可以将其用于测试集。在这里H函数不一定是一个可导的函数。并且<strong>有一定过拟合风险</strong></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p>我们的模型预测的结果是连续的数值 $[0, 5]$，但是我们评价指标要求我们最后的结果必须是整数 ${0,1,2,3,4}$,这个时候应该选取怎样的阈值，将哪个区间的划分为1，哪个区间划分为2？ 直觉上可以会将模型得到的结果属于 $[0.5, 1.5]$的数值划分为1，但是由于模型的特殊性，由这个模型得到的这个预测结果使用这个划分区间不是最优解，于是我们可以把这些划分区间的阈值假设为$\alpha_1, \alpha_2,…$， 则$[0, \alpha_1]$ 划分为0，$[\alpha_1, \alpha_2] $划分为1…</p><p>代码:</p><p><strong>定义优化函数</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> partial<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> scipy <span class="token keyword">as</span> sp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">Result</span><span class="token punctuation">(</span>coef<span class="token punctuation">,</span> y_pred<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># coef 就是置信度，也就是 上述的 α集合，该函数定义了我们的评价结果 Results</span>    <span class="token comment"># --------------- H 函数 -------------------#</span>    H <span class="token operator">=</span> np<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>y_pred<span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> pred <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pred <span class="token operator">&lt;</span> coef<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">elif</span> pred <span class="token operator">>=</span> coef<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">and</span> pred <span class="token operator">&lt;</span> coef<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> pred <span class="token operator">>=</span> coef<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> pred <span class="token operator">&lt;</span> coef<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>        <span class="token keyword">elif</span> pred <span class="token operator">>=</span> coef<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> pred <span class="token operator">&lt;</span> coef<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>        <span class="token comment"># --------------- H 函数 -------------------#  </span>                    ll <span class="token operator">=</span> G<span class="token punctuation">(</span>H<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span> <span class="token comment"># 其中G就是我们的评价指标</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ll  <span class="token comment"># 如果我们想要取到最大值，我们需要取负变成求最小值，反之不用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>得到最优参数</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span><span class="token punctuation">:</span>    loss_partial <span class="token operator">=</span> partial<span class="token punctuation">(</span>Result<span class="token punctuation">,</span> y_pred<span class="token operator">=</span>y_pred<span class="token punctuation">,</span> y_true<span class="token operator">=</span>y_true<span class="token punctuation">)</span> <span class="token comment"># Python 内置函数，将参数内置在函数中，方便后续处理</span>    initial_coef <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">]</span> <span class="token comment"># 初始化</span>    coef_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>loss_partial<span class="token punctuation">,</span> initial_coef<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'nelder-mead'</span><span class="token punctuation">)</span> <span class="token comment"># 优化方法，最后得到就是我们的最优边界</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><p>$f1_score$的优化，对于分类模型，往往需要确定一个比较好的阈值来划分不同类别的样本，于是设定不同的阈值就变成了一种艺术，假设我们的模型在验证集上的输出结果  $ y_{pred}$的形状是 $[n,n_classs]$, $n$ 是样本数，$n_class$是 类别数，于是我们可以设置一个权重系数$coff$，形状为 $[1, n_class]$ 初始化为 $[0.5, 0.5,…]$ ,于是我们的$H$ 函数就可以表示为 $H(y_pred, coff) &#x3D;np.argmax(y_{pred}*coff)$</p><p>代码如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">Result</span><span class="token punctuation">(</span>coef<span class="token punctuation">,</span> y_pred<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># coef 就是置信度，也就是 上述的 α集合，该函数定义了我们的评价结果 Results</span>        <span class="token comment"># --------------- H 函数 -------------------#</span>    H <span class="token operator">=</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>y_pred<span class="token operator">*</span>coff<span class="token punctuation">)</span>    <span class="token comment"># --------------- H 函数 -------------------#  </span>         ll <span class="token operator">=</span> f1_score<span class="token punctuation">(</span>H<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span> <span class="token comment"># 其中G就是我们的评价指标</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ll  <span class="token comment"># 如果我们想要取到最大值，我们需要取负变成求最小值，反之不用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span><span class="token punctuation">:</span>    loss_partial <span class="token operator">=</span> partial<span class="token punctuation">(</span>Result<span class="token punctuation">,</span> y_pred<span class="token operator">=</span>y_pred<span class="token punctuation">,</span> y_true<span class="token operator">=</span>y_true<span class="token punctuation">)</span> <span class="token comment"># Python 内置函数，将参数内置在函数中，方便后续处理</span>    initial_coef <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 初始化</span>    coef_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>loss_partial<span class="token punctuation">,</span> initial_coef<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'nelder-mead'</span><span class="token punctuation">)</span> <span class="token comment"># 优化方法，最后得到就是我们的最优权重</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>改方法主要是针对数据进行后处理，在某一些比赛可能取的奇效</li><li>该方法简单实用，并且在后处理过程中 $H$ 函数不一定非要连续或者可导函数</li><li>该方法有一定可能性<strong>导致过拟合</strong>，因为验证集并不能代表测试集，只能在一定程度上有用</li><li>由于该方法依赖传统优化算法，<strong>所以可能存在陷入极小值的局限性</strong>，不过可以多试试不同的优化算法，经过测试，<code>&#39;Nelder-Mead&#39;,&#39;Powell&#39;,&#39;CG&#39;,&#39;BFGS&#39;,&#39;L-BFGS-B&#39;,&#39;TNC&#39;,&#39;COBYLA&#39;,&#39;SLSQP&#39;,&#39;trust-constr&#39;</code> 这些优化算法中<code>Nelder-Mead&#39;,&#39;Powell&#39;,&#39;COBYLA&#39;</code> 在随机数据上能克服陷入极小值的可能性，但是在实际比赛数据中还没有做过具体的测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 比赛相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 后处理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
